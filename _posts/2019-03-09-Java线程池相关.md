## Java线程池相关

### 1.参数释义

Executor接口的实现类：**ThreadPoolExecutor** 

```java
public ThreadPoolExecutor(int corePoolSize, 
                    int maximumPoolSize, 
                    long keepAliveTime, 
                    TimeUnit unit, 
                    BlockingQueue<Runnable> workQueue, 
                    ThreadFactory threadFactory, 
                    RejectedExecutionHandler handler);
```

**corePoolSize** ：线程池的核心线程数量，核心线程即使在没有用的时候，也不会被回收；

**maximumPoolSize** ：线程池中的最大线程数量；

**keepAliveTime** ：线程池中除了核心线程之外的其他线程最长可以保留的时间；

**util** ：计算这个时间的单位；

**workQueue** ：等待队列，任务可以储存在任务队列中等待被执行，按照**FIFO（先进先出）**原则执行；

**threadFactory** ：创建线程的线程工厂；

**handler** ：拒绝策略，在任务满了之后，拒绝执行某些任务。

### 2.执行流程

任务进来时，首先判断核心线程是否处于空闲状态，如果有空闲，核心线程就先执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，如果有，就将任务保存在任务队列中，等待执行，如果满了，再判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。

### 3.handler的拒绝策略

handler的拒绝策略有四种：

**AbortPolicy：** 不执行新任务，直接抛出异常，提示线程池已满；

**DisCardPolicy：** 不执行新任务，也不抛出异常；

**DisCardOldSetPolicy：** 将消息队列中的第一个任务替换为当前新进来的任务执行；

**CallerRunsPolicy：** 直接调用execute执行当前任务。

### 4.五种种线程池

**newCachedThreadPool()：** 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程；最大线程数为Integer.MAX_VALUE，容易造成**内存泄漏**。

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            60L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
}
```

**newFixedThreadPool()：** 创建定长线程池，可控制最大并发数，超出的线程在队列种等待；不会复用线程，每运行一个Runnable都会通过ThreadFactory创建一个线程；如果定长的数量设置的过小，有可能造成**任务堆积** ，最好根据系统资源进行设置，如`Runtime.getRuntime().availableProcessors()`。

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(),
            threadFactory);
}
```

**newScheduledThreadPool()：** 创建定长线程池，支持定时及周期性任务执行。设计思想是：每一个被调度的任务都会由线程池中一个线程去执行，因此任务是**并发执行**的，相互之间不会受到干扰。只有当任务的执行时间到来时，才会真正启动一个线程，其余时间都是在轮询任务的状态。

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```

```java
public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory);
}
```

**newSingleThreadExecutor()：** 创建单线程化的线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行。

```java
public static ExecutorService newSingleThreadExecutor() {
    return new Executors.FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                    0L, TimeUnit.MILLISECONDS,
                    new LinkedBlockingQueue<Runnable>()));
}
```

**newWorkStealingPool()：** jdk1.8新增，**根据所需要的并行层次动态创建和关闭线程**，通过使用多个队列减少竞争，底层用`ForkJoinPool `实现，可以充分利用多核cpu的优势，把一个任务拆分成多个小任务，多个小任务在多个处理器上并行执行，都执行完之后，再将这些执行结果合并起来。

```java
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
            (Runtime.getRuntime().availableProcessors(),
                    ForkJoinPool.defaultForkJoinWorkerThreadFactory,
                    null, true);
}
```

### 参考：

https://blog.csdn.net/weixin_40271838/article/details/79998327

https://blog.csdn.net/wy11933/article/details/80399562
