### Java同步工具类

### 1.Semaphore（信号量）

跟锁机制有一定的相似性，`semaphore`也是一种锁机制，不同的是，reentrantLock只允许一个线程获得锁，而信号量持有多个许可（permits），允许多个线程获得许可并执行。可以用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。

### 2.CountDownLatch（闭锁）

允许一个或多个线程一直等待，直到其他线程操作执行完成后再执行。

`CountDownLatch`通过一个计数器实现，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。

主要方法：

`CountDownLatch.await()`：将某个线程阻塞住，直到计数器count=0才恢复执行。

`CountDownLatch.countDown()`：将计数器count减1。

使用场景：

1.实现最大的并行性：有时想启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类，如果创建一个初始计数为1的`CountDownLatch`，并让所有线程都在这个锁上等待，那么我们可以很轻松的完成测试。我们只需调用一个`countDown()`方法就可以让所有等待线程同时恢复执行。

2.开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和执行了。

3.死锁检测：一个非常方便的使用场景是，可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。

4.计算并发执行某个任务的耗时。

### 3.CyclicBarrier（栅栏）

用于阻塞一组线程直到某个事件发生。所有线程必须同时到达栅栏位置才能继续执行下一步操作，且能够被重置以达到重复利用。而闭锁是一次性对象，一旦进入终止状态，就不能被重置。

### 4.Phaser

相当于`CyclicBarrier`的改良版，运行阶段性的并发任务。当某些并发任务是分成多个步骤来执行的，就可以使用`Phaser`来执行。`Phaser`类提供的机制是在每个步骤的结尾同步线程，所以除非全部线程完成第一个步骤，否则线程不能开始进行第二步。

### 5.Exchanger（交换器）

`Exchanger`类允许在两个线程间定义同步点，当两个线程到达这个点，他们相互交换数据类型，使用第一个线程的数据类型变成第二个的，然后第二个线程的数据类型变成第一个的。

### 6.Monitor（管程）

管程（Monitors，也叫监视器）是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程**互斥访问共享资源**。管程实现了在一个时间点最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现访问的并发程序设计相比，管程实现很大程度上简化了程序设计。管程提供了一种机制，线程可以**临时放弃互斥访问**，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。

#### 6.1 特点

Monitor其实是一种同步工具，也可以说是一种同步机制，通常被描述为一个对象，主要的特点是：

对象的所有方法都被互斥的执行。好比一个Monitor只有一个运行许可，任一个线程进入任何一个方法都需要获得这个许可，离开时把许可归还；

通过提供singal机制：允许正持有许可的线程暂时放弃许可，等待某个条件变量成真，而条件成立后，当前进程可以通知正在等待这个条件变量的线程，让它可以重新去获取运行许可。

#### 6.2 线程同步相关的Monitor

在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制，互斥锁机制，这些机制保证了在同一个时刻只有一个线程能访问共享资源。这些机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。

#### 6.3 Monitor的实现

HotSpot中，Monitor由ObjectMonitor实现，基于C++。有几个关键属性：

`_owner`：指向持有ObjectMonitor对象的线程；

`_WaitSet`：存放处于wait状态的线程队列；

`_EntryList`：存放处于等待锁block状态的线程队列；

`_recursions`：锁的重入次数；

`_count`：用来记录该线程获取锁的次数。

当多个线程同时访问一段同步代码时，首先会进入`_EntryList`队列中，当某个线程获取到对象的Monitor后进入`_Owner`区域并把Monitor中的`_Owner`变量设置为当前线程，同时Monitor中的计数器`_count`加1。即获得对象锁。

若持有Monitor的线程调用`wait()`方法，将释放当前持有的Monitor，`_Owner`变量恢复为`null`，`_count`自减1，同时该线程进入`_WaitSet`集合中等待被唤醒。若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取Monitor。

### 参考：

<https://blog.csdn.net/u010942020/article/details/79352560>

<https://www.hollischuang.com/archives/2030>