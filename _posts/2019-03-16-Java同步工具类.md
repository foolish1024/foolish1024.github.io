---

layout: post
title: Java同步工具类
categories: JAVA基础
description: Java同步工具类介绍。
keywords: JAVA,同步,多线程

---

## Java同步工具类

### 1.Semaphore（信号量）

跟锁机制有一定的相似性，`semaphore`也是一种锁机制，不同的是，reentrantLock只允许一个线程获得锁，而信号量持有多个许可（permits），允许多个线程获得许可并执行。可以用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。

### 2.CountDownLatch（闭锁）

允许一个或多个线程一直等待，直到其他线程操作执行完成后再执行。**AQS共享模式的实现。**

`CountDownLatch`通过一个计数器实现，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。

主要方法：

`CountDownLatch.await()`：将某个线程阻塞住，直到计数器count=0才恢复执行。

`CountDownLatch.countDown()`：将计数器count减1。

使用场景：

1.实现最大的并行性：有时想启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类，如果创建一个初始计数为1的`CountDownLatch`，并让所有线程都在这个锁上等待，那么我们可以很轻松的完成测试。我们只需调用一个`countDown()`方法就可以让所有等待线程同时恢复执行。

2.开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和执行了。

3.死锁检测：一个非常方便的使用场景是，可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。

4.计算并发执行某个任务的耗时。

### 3.CyclicBarrier（栅栏）

**AQS独占模式+Condition的实现。**
用于阻塞一组线程直到某个事件发生。所有线程必须同时到达栅栏位置才能继续执行下一步操作，且能够被重置以达到重复利用。而闭锁是一次性对象，一旦进入终止状态，就不能被重置。

### 4.Phaser

相当于`CyclicBarrier`的改良版，运行阶段性的并发任务。当某些并发任务是分成多个步骤来执行的，就可以使用`Phaser`来执行。`Phaser`类提供的机制是在每个步骤的结尾同步线程，所以除非全部线程完成第一个步骤，否则线程不能开始进行第二步。

### 5.Exchanger（交换器）

`Exchanger`类允许在两个线程间定义同步点，当两个线程到达这个点，他们相互交换数据类型，使用第一个线程的数据类型变成第二个的，然后第二个线程的数据类型变成第一个的。

### 参考：

[Java并发包之闭锁/栅栏/信号量](https://blog.csdn.net/u010942020/article/details/79352560)
